# 线性表

## 动态数组（实现顺序表）

* 特点：内存连续

1. 优点
   * 下标访问（随机访问）时间复杂度是O(1)
   * 尾删、尾插时间复杂度是O(1)
   * 访问元素前后相邻位置的元素非常方便

2. 缺点
   * 非末尾位置增删元素需要进行大量的数据移动
   * 搜索的时间复杂度
     * 无序数组：线性搜索O(n)
     * 有序数组：二分搜索O($\log{n}$)
   * 数组扩容消耗比较大

3. 适用场景
   * **需要频繁随机访问**的场景
   * **尾部操作频繁**的场景
   * **数据量相对固定**或**可预测**的情况
   * **缓存友好**的高性能计算

## 链表

* 特点：每一个节点都是在堆内存上独立new出来的，节点内存不连续

1. 优点
   * 内存利用率高，不需要大块连续内存
   * 插入和删除节点不需要移动其他节点，时间复杂度O(1)
   * 不需要专门进行扩容操作

2. 缺点
   * 内存占用量大，每一个节点多处存放地址的空间
   * 节点内存不连续，无法进行内存随机访问
   * 链表搜索效率不高，只能从头结点开始逐节点遍历

3. 适用场景
   * **频繁在任意位置插入删除**的场景
   * **内存碎片化**的环境
   * **数据规模动态变化**的情况
   * **实现队列、栈**等数据结构

4. 注意事项
   * 对于使用智能指针管理的链表，常用**原始指针**进行遍历，使用**智能指针**进行节点管理
   * 对于循环链表，用cur_ptr是否等于头节点进行判断；而对于非循环链表，用cur_ptr是否为空进行判断
   * 对于单项链表，由于节点的所有权在上一个节点，因此常用双链表进行节点操作
   * 对于有尾节点的链表，需要注意边界问题。

### 单向链表

* 特点：
  1. 每一个节点除了数据域，还有一个next指针指向下一个节点的地址。但是无法回退到前一个节点
  2. 末尾节点的指针域是nullptr

* 适用场景：
  * **简单的先进先出队列**
  * **只需要单向遍历**的场景
  * **内存极度受限**的环境

### 单向循环链表

* 特点：末尾节点的地址域存储的是首节点的地址

* 适用场景：
  * **轮询调度算法**
  * **环形缓冲区**
  * **约瑟夫环**等问题

### 双向链表

* 特点：
  1. 每一个节点除了数据域，还有next指针指向下一个节点，pre指针指向前一个节点
  2. 头结点的pre是nullptr，末尾节点的next是nullptr

* 适用场景：
  * **需要双向遍历**的场景
  * **LRU缓存淘汰算法**
  * **文本编辑器**的光标移动

### 双向循环链表

* 特点：
  1. 每一个节点除了数据域，还有next指针指向下一个节点，pre指针指向前一个节点
  2. 头节点的pre指向末尾节点，末尾节点的pre指向头节点

* 适用场景：
  * **需要循环双向遍历**的场景
  * **音乐播放列表**
  * **浏览器历史记录**导航

## 栈

* 特点：先进后出，后进先出

### 顺序栈

依赖数组实现

* 适用场景：
  * **固定大小**的栈需求
  * **性能要求高**的场景
  * **内存连续**访问模式

### 链式栈

依赖链表实现

* 适用场景：
  * **动态大小**的栈需求
  * **内存受限**的环境
  * **不需要随机访问**的场景

## 队列

* 特点：先进先出，后进后出

* 适用场景：
  * **任务调度系统**
  * **消息队列**
  * **广度优先搜索**
  * **缓存系统**

# 搜索

## 二分搜索

⭐二分搜索严格要求数据有序！

* 时间复杂度$O(\log_2{n})$
* 空间复杂度
  * 迭代$O(1)$
  * 递归$O(\log_2n)$

* 适用场景：
  * **静态有序数据集**
  * **需要频繁搜索**的场景
  * **数据量较大**的情况

## 排序算法

关注算法的**时间复杂度（平均、最优、最差）**和**空间复杂度**和**稳定性**。

---

## 1. 冒泡排序（Bubble Sort）

- **特点**：相邻元素两两比较，把值大的元素往下交换（沉底），每轮将最大元素放到最终位置。
- **优点**：实现简单，稳定排序。
- **缺点**：数据交换次数太多，时间复杂度高，效率低。
- **时间复杂度**：
  - 平均：O(n²)
  - 最坏：O(n²)
  - 最好：O(n)（已优化情况下，若已有序可提前结束）
- **空间复杂度**：O(1)
- **适用场景**：
  * **教学演示**算法原理
  * **小规模数据**排序（n < 50）
  * **检测数据是否已排序**

---

## 2. 选择排序（Selection Sort）

- **特点**：每次在剩余元素中选择最小的元素，与当前位置交换。
- **优点**：交换次数少（最多 n-1 次交换），不占用额外空间。
- **缺点**：比较次数依然很多，不稳定（如果交换时跨过了相等元素可能改变顺序）。
- **时间复杂度**：平均、最坏、最好均为 O(n²)
- **空间复杂度**：O(1)
- **适用场景**：
  * **交换成本高**的环境（如Flash存储器）
  * **小规模数据**排序
  * **需要最小化写入次数**的场景

---

## 3. 插入排序（Insertion Sort）

- **特点**：将每个元素插入到前面已排序序列的适当位置。
- **优点**：
  - 对小数据量或基本有序的数据效率很高。
  - 稳定排序，原地排序。
  - 在数据趋于有序时，效率接近 O(n)。
- **缺点**：数据规模大且无序时比较和移动次数多。
- **时间复杂度**：
  - 平均：O(n²)
  - 最坏：O(n²)
  - 最好：O(n)（已有序时）
- **空间复杂度**：O(1)
- **适用场景**：
  * **小数据量**（n < 50）排序
  * **基本有序数据**的排序
  * **作为其他算法的优化子过程**（如快速排序的小数组处理）
  * **在线算法**（数据逐个到达时排序）

---

## 4. 希尔排序（Shell Sort）

- **特点**：是插入排序的改进，通过分组进行间隔排序，逐渐缩小组的间隔，最终变成插入排序。
- **优点**：比 O(n²) 的简单排序快很多，中等规模数据表现不错。
- **缺点**：时间复杂度依赖于间隔序列，不稳定。
- **时间复杂度**：根据间隔序列不同，大约在 O(n log n) 到 O(n^(3/2)) 之间。
- **空间复杂度**：O(1)
- **适用场景**：
  * **中等规模数据**（50 < n < 5000）
  * **需要原地排序**且比插入排序更快的场景
  * **对缓存性能要求不高**的环境

---

## 5. 快速排序（Quick Sort）

* **适用场景**：
  1. 内存连续，缓存友好
  2. 大数据量，数据乱序
  3. 通用内存排序
  4. 对性能要求高的场景

- **特点**：分治法，选取一个基准，将小于基准的放左边，大于基准的放右边，递归排序左右。
- **优点**：平均情况下非常快，缓存友好，原地排序（可做到）。
- **缺点**：最坏情况 O(n²)（如已有序且选基准不好），不稳定。
- **时间复杂度**：
  - 平均：O(n log n)
  - 最坏：O(n²)
  - 最好：O(n log n)
- **空间复杂度**：平均 O(log n)（递归调用栈），最坏 O(n)
- **算法优化**：
  1. 随着快排的进行，数据越来越趋于有序，因此可以在数据量较小时使用插入排序
  2. 采用"三数取中"法（比较数据第一个、最后一个、中间的数这三个数，取数值在中间的数和第一个数交换，然后再开始快排，这样可以杜绝最坏的情况），找合适的基准数

---

## 6. 归并排序（Merge Sort）

- **特点**：分治法，将数组分成两半分别排序，然后合并。
- **优点**：稳定，时间复杂度稳定为 O(n log n)，适合外部排序。
- **缺点**：需要 O(n) 额外空间（非原地）。
- **时间复杂度**：平均、最坏、最好均为 O(n log n)
- **空间复杂度**：O(n) (要用新数组存储排序后的数据，数组最大为数据总量)
- **适用场景**：
  * **需要稳定排序**的场景
  * **外部排序**（数据太大无法全部装入内存）
  * **链表排序**
  * **并行计算**环境

---

## 7. 堆排序（Heap Sort）

- **特点**：利用堆这种数据结构，先建堆，然后不断取出堆顶元素(因为堆顶元素总是最大/最小)。
- **优点**：时间复杂度稳定 O(n log n)，原地排序。
- **缺点**：不稳定，常数因子较大，缓存不友好，sift_down过程中有大量冗余比较
- **时间复杂度**：平均、最坏、最好均为 O(n log n)
- **空间复杂度**：O(1)
- **适用场景**：
  * **内存受限**环境
  * **需要保证最坏情况性能**的实时系统
  * **需要部分排序**（如TopK问题）
  * **优先级队列**实现

---

## 8. 计数排序（Counting Sort）

- **特点**：非比较排序，适用于整数且范围不大的情况。
- **优点**：速度快 O(n+k)，k 为数据范围。
- **缺点**：需要额外空间，只适用于整数且范围小的情况。
- **时间复杂度**：O(n+k)
- **空间复杂度**：O(k)
- **适用场景**：
  * **小范围整数**排序
  * **需要稳定排序**的整数
  * **作为基数排序的子过程**
  * **统计频率**的场景

---

## 9. 桶排序（Bucket Sort）

- **特点**：将数据分到有限数量的桶里，每个桶单独排序（可用其他排序方法），排序后根据每个桶数据的最值进行综合排序
- **优点**：在数据分布均匀时，平均时间复杂度 O(n)。
- **缺点**：需要额外空间，受数据分布影响大。
- **时间复杂度**：平均 O(n+k)，最坏 O(n²)
- **空间复杂度**：O(n+k)
- **适用场景**：
  * **均匀分布数据**排序
  * **外部排序**
  * **非比较排序**适用的场景
  * **浮点数**排序

---

## 10. 基数排序（Radix Sort）

- **特点**：按位排序，从低位到高位（LSD）或高位到低位（MSD），通常使用稳定排序作为子排序。
- **优点**：适用于整数或字符串排序，稳定（如果子排序稳定）。
- **缺点**：需要额外空间，位数多时可能不如快速排序。
- **时间复杂度**：O(d×(n+k))（d 为最大位数，k 为基数大小）
- **空间复杂度**：O(n+k)
- **适用场景**：
  * **整数或字符串**排序
  * **数据位数相对较少**的情况
  * **需要稳定排序**的大整数
  * **多关键字排序**

---

## 排序算法总结表

| 排序算法     | 平均时间复杂度      | 最好情况    | 最坏情况   | 空间复杂度 | 稳定性   | 适用场景               |
| :----------- | :------------------ | :---------- | :--------- | :--------- | :------- | :--------------------- |
| **冒泡排序** | O(n²)               | O(n)        | O(n²)      | O(1)       | ✅ 稳定   | 教学、小规模数据       |
| **选择排序** | O(n²)               | O(n²)       | O(n²)      | O(1)       | ❌ 不稳定 | 交换成本高的场景       |
| **插入排序** | O(n²)               | O(n)        | O(n²)      | O(1)       | ✅ 稳定   | 小规模、基本有序数据   |
| **希尔排序** | O(n log n) O(n^1.3) | O(n log² n) | O(n²)      | O(1)       | ❌ 不稳定 | 中等规模数据           |
| **归并排序** | O(n log n)          | O(n log n)  | O(n log n) | O(n)       | ✅ 稳定   | 大规模、稳定排序需求   |
| **快速排序** | O(n log n)          | O(n log n)  | O(n²)      | O(log n)   | ❌ 不稳定 | 通用、大规模数据       |
| **堆排序**   | O(n log n)          | O(n log n)  | O(n log n) | O(1)       | ❌ 不稳定 | 内存受限、最坏情况保证 |
| **计数排序** | O(n + k)            | O(n + k)    | O(n + k)   | O(k)       | ✅ 稳定   | 整数、小范围数据       |
| **桶排序**   | O(n + k)            | O(n + k)    | O(n²)      | O(n + k)   | ✅ 稳定   | 均匀分布数据           |
| **基数排序** | O(n × k)            | O(n × k)    | O(n × k)   | O(n + k)   | ✅ 稳定   | 整数、字符串排序       |

## 排序算法常见问题

1. STL中使用的sort算法使用的是什么算法？

   * 快速排序算法，数据量<= 32时使用插入排序，递归层数太深时为了防止撑破栈使用堆排序（不使用归并排序是引起其需要占用额外的空间，希尔排序则有最坏的时间复杂度）

2. 如何解决快排时间复杂度恶化问题？

   * 元素较少时使用插入排序
   * 使用"三数取中"法选择基准元素

3. 快速排序递归实现时，怎么解决递归层次过深问题？

   ```c++
   //1.使用ideal - 基于问题规模衰减的方法
   ideal = n;
   while(ideal > 1)
   {
       ideal = (ideal >> 1) + (ideal >> 2);  
       // ideal *= 3/4;
   }
   
   //2.使用递归深度限制 - 固定深度方法
   for(int i =  2 * log₂(n); i > 0; i--)
   {}
   ```

   这两者的区别是，前者的递归深度限制允许比后者稍大

4. 递归过深会导致什么问题？

   * 函数开销变大；导致栈内存溢出，程序挂掉

5. 怎么控制递归深度？如果达到了递归深度还没排完序怎么办？

   * 转成非递归排序算法（比如堆排序）

6. 实际应用中选择排序算法的建议：

   * **n < 50**：插入排序
   * **50 < n < 1000**：希尔排序或快速排序
   * **n > 1000**：快速排序或归并排序
   * **需要稳定性**：归并排序
   * **内存紧张**：堆排序
   * **数据基本有序**：插入排序
   * **数据均匀分布**：桶排序
   * **小范围整数**：计数排序

# 哈希表

