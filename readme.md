# 线性表

## 动态数组（实现顺序表）

* 特点：内存连续

1. 优点

   * 下标访问（随机访问）时间复杂度是O(1)
   * 尾删、尾插时间复杂度是O(1)
   * 访问元素前后相邻位置的元素非常方便

2. 缺点

   * 非末尾位置增删元素需要进行大量的数据移动

   * 搜索的时间复杂度

     * 无序数组：线性搜索O(n)
     * 有序数组：二分搜索O($\log{n}$)

     数组扩容消耗比较大

3. 注意事项

   * 数组的查找（搜索）和下标访问（随机访问）是不同的概念！
     前者是根据元素找到对应的索引，后者是根据索引给出对应的元素。

## 链表

* 特点：每一个节点都是在堆内存上独立new出来的，节点内存不连续

1. 优点
   * 内存利用率高，不需要大块连续内存
   * 插入和删除节点不需要移动其他节点，时间复杂度O(1)
   * 不需要专门进行扩容操作
2. 缺点
   * 内存占用量大，每一个节点多处存放地址的空间
   * 节点内存不连续，无法进行内存随机访问
   * 链表搜索效率不高，只能从头结点开始逐节点遍历
3. 总结
   * 对于使用智能指针管理的链表，常用**原始指针**进行遍历，使用**智能指针**进行节点管理
   * 对于循环链表，用cur_ptr是否等于头节点进行判断；而对于非循环链表，用cur_ptr是否为空进行判断
   * 对于单项链表，由于节点的所有权在上一个节点，因此常用双链表进行节点操作
   * 对于有尾节点的链表，需要注意边界问题。



### 单向链表

* 特点：
   1. 每一个节点除了数据域，还有一个next指针指向下一个节点的地址。
      但是无法回退到前一个节点
   2. 末尾节点的指针域是nullptr

### 单向循环链表

* 特点：末尾节点的地址域存储的是首节点的地址

### 双向链表

* 特点：

1. 每一个节点除了数据域，还有next指针指向下一个节点，pre指针指向前一个节点
2. 头结点的pre是nullptr，末尾节点的next是nullptr

### 双向循环链表

* 特点：

1. 每一个节点除了数据域，还有next指针指向下一个节点，pre指针指向前一个节点
2. 头节点的pre指向末尾节点，末尾节点的pre指向头节点

## 栈

* 特点：先进后出，后进先出

### 顺序栈

依赖数组实现

### 链式栈

依赖链表实现

## 队列

* 特点：先进先出，后进后出

# 搜索

## 二分搜索

⭐二分搜索严格要求数据有序！

* 时间复杂度$O(\log_2{n})$
* 空间复杂度
  * 迭代$O(1)$
  * 递归$O(\log_2n)$

## 排序算法

关注算法的**时间复杂度（平均、最优、最差）**和**空间复杂度**和**稳定性**。

---

## 1. 冒泡排序（Bubble Sort）

- **特点**：相邻元素两两比较，把值大的元素往下交换（沉底），每轮将最大元素放到最终位置。
- **优点**：实现简单，稳定排序。
- **缺点**：数据交换次数太多，时间复杂度高，效率低。
- **时间复杂度**：
  - 平均：O(n²)
  - 最坏：O(n²)
  - 最好：O(n)（已优化情况下，若已有序可提前结束）
- **空间复杂度**：O(1)

---

## 2. 选择排序（Selection Sort）

- **特点**：每次在剩余元素中选择最小的元素，与当前位置交换。
- **优点**：交换次数少（最多 n-1 次交换），不占用额外空间。
- **缺点**：比较次数依然很多，不稳定（如果交换时跨过了相等元素可能改变顺序）。
- **时间复杂度**：平均、最坏、最好均为 O(n²)
- **空间复杂度**：O(1)

---

## 3. 插入排序（Insertion Sort）

- **特点**：将每个元素插入到前面已排序序列的适当位置。
- **优点**：
  - 对小数据量或基本有序的数据效率很高。
  - 稳定排序，原地排序。
  - 在数据趋于有序时，效率接近 O(n)。
- **缺点**：数据规模大且无序时比较和移动次数多。
- **时间复杂度**：
  - 平均：O(n²)
  - 最坏：O(n²)
  - 最好：O(n)（已有序时）
- **空间复杂度**：O(1)

---

## 4. 希尔排序（Shell Sort）

- **特点**：是插入排序的改进，通过分组进行间隔排序，逐渐缩小组的间隔，最终变成插入排序。
- **优点**：比 O(n²) 的简单排序快很多，中等规模数据表现不错。
- **缺点**：时间复杂度依赖于间隔序列，不稳定。
- **时间复杂度**：根据间隔序列不同，大约在 O(n log n) 到 O(n^(3/2)) 之间。
- **空间复杂度**：O(1)

---

## 5. 快速排序（Quick Sort）

- **特点**：分治法，选取一个基准，将小于基准的放左边，大于基准的放右边，递归排序左右。
- **优点**：平均情况下非常快，缓存友好，原地排序（可做到）。
- **缺点**：最坏情况 O(n²)（如已有序且选基准不好），不稳定。
- **时间复杂度**：
  - 平均：O(n log n)
  - 最坏：O(n²)
  - 最好：O(n log n)
- **空间复杂度**：平均 O(log n)（递归栈），最坏 O(n)
- **算法优化**：
  1. 随着快排的进行，数据越来越趋于有序，因此可以在数据量较小时使用插入排序
  2. 采用“三数取中”法（比较数据第一个、最后一个、中间的数这三个数，取数值在中间的数和第一个数交换，然后再开始快排，这样可以杜绝最坏的情况），找合适的基准数

---

## 6. 归并排序（Merge Sort）

- **特点**：分治法，将数组分成两半分别排序，然后合并。
- **优点**：稳定，时间复杂度稳定为 O(n log n)，适合外部排序。
- **缺点**：需要 O(n) 额外空间（非原地）。
- **时间复杂度**：平均、最坏、最好均为 O(n log n)
- **空间复杂度**：O(n)

---

## 7. 堆排序（Heap Sort）

- **特点**：利用堆这种数据结构，先建堆，然后不断取出堆顶元素(因为堆顶元素总是最大/最小)。
- **优点**：时间复杂度稳定 O(n log n)，原地排序。
- **缺点**：不稳定，常数因子较大，缓存不友好。
- **时间复杂度**：平均、最坏、最好均为 O(n log n)
- **空间复杂度**：O(1)

---

## 8. 计数排序（Counting Sort）

- **特点**：非比较排序，适用于整数且范围不大的情况。
- **优点**：速度快 O(n+k)，k 为数据范围。
- **缺点**：需要额外空间，只适用于整数且范围小的情况。
- **时间复杂度**：O(n+k)
- **空间复杂度**：O(k)

---

## 9. 桶排序（Bucket Sort）

- **特点**：将数据分到有限数量的桶里，每个桶单独排序（可用其他排序方法）。
- **优点**：在数据分布均匀时，平均时间复杂度 O(n)。
- **缺点**：需要额外空间，受数据分布影响大。
- **时间复杂度**：平均 O(n+k)，最坏 O(n²)
- **空间复杂度**：O(n+k)

---

## 10. 基数排序（Radix Sort）

- **特点**：按位排序，从低位到高位（LSD）或高位到低位（MSD），通常使用稳定排序作为子排序。
- **优点**：适用于整数或字符串排序，稳定（如果子排序稳定）。
- **缺点**：需要额外空间，位数多时可能不如快速排序。
- **时间复杂度**：O(d×(n+k))（d 为最大位数，k 为基数大小）
- **空间复杂度**：O(n+k)

---



| 排序算法     | 平均时间复杂度      | 最好情况    | 最坏情况   | 空间复杂度 | 稳定性   | 适用场景             |
| :----------- | :------------------ | :---------- | :--------- | :--------- | :------- | :------------------- |
| **冒泡排序** | O(n²)               | O(n)        | O(n²)      | O(1)       | ✅ 稳定   | 教学、小规模数据     |
| **选择排序** | O(n²)               | O(n²)       | O(n²)      | O(1)       | ❌ 不稳定 | 教学、小规模数据     |
| **插入排序** | O(n²)               | O(n)        | O(n²)      | O(1)       | ✅ 稳定   | 小规模、基本有序数据 |
| **希尔排序** | O(n log n) O(n^1.3) | O(n log² n) | O(n²)      | O(1)       | ❌ 不稳定 | 中等规模数据         |
| **归并排序** | O(n log n)          | O(n log n)  | O(n log n) | O(n)       | ✅ 稳定   | 大规模数据、外部排序 |
| **快速排序** | O(n log n)          | O(n log n)  | O(n²)      | O(log n)   | ❌ 不稳定 | 通用、大规模数据     |
| **堆排序**   | O(n log n)          | O(n log n)  | O(n log n) | O(1)       | ❌ 不稳定 | 需要O(1)空间时       |
| **计数排序** | O(n + k)            | O(n + k)    | O(n + k)   | O(k)       | ✅ 稳定   | 整数、小范围数据     |
| **桶排序**   | O(n + k)            | O(n + k)    | O(n²)      | O(n + k)   | ✅ 稳定   | 均匀分布数据         |
| **基数排序** | O(n × k)            | O(n × k)    | O(n × k)   | O(n + k)   | ✅ 稳定   | 整数、字符串排序     |
