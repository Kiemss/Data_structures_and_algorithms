 ## 图 (Graph) 

  **图的定义**

  图是由**顶点集合**和**边集合**组成的数据结构，表示为 `G = (V, E)`。

  **图的分类**

  | 分类标准   | 类型     | 特点                 |
  | ---------- | -------- | -------------------- |
  | **边方向** | 有向图   | 边有方向，用箭头表示 |
  |            | 无向图   | 边无方向，用线段表示 |
  | **边权重** | 带权图   | 边有权重值           |
  |            | 无权图   | 边无权重值           |
  | **连通性** | 连通图   | 任意两顶点间都有路径 |
  |            | 非连通图 | 存在不连通的顶点     |

  **图的基本术语**

  * **顶点/节点**：图的基本元素
  * **边/弧**：顶点间的连接
  * **度**：与顶点相连的边数
  * **路径**：顶点序列，相邻顶点间有边
  * **环**：起点和终点相同的路径
  * **连通分量**：极大连通子图

---

  ## 图的存储结构扩展

### 邻接矩阵 (Adjacency Matrix)

  * **结构原理**
    * 使用二维数组表示顶点间的邻接关系
    * 矩阵维度为 n × n（n为顶点数）
    * `matrix[i][j] = 0` 表示无边，`matrix[i][j] = w` 表示有边且权重为w
    * 对角线存储顶点信息，非对角线存储边信息

  * **特点分析**
    * 空间复杂度：O(n²)
    * 适用稠密图，快速判断边存在性
    * 优势：随机访问快，实现简单
    * 劣势：稀疏图空间浪费严重

  ### 邻接表 (Adjacency List)

  * **结构原理**
    * 为每个顶点维护邻接顶点链表
    * 数组结构存储链表头指针
    * 链表节点包含邻接顶点编号、边权重、下一节点指针

  * **变体优化**
    * 向量代替链表：`vector<vector<pair<int, int>>>`
    * 哈希表邻接表：`unordered_map<string, vector<pair<string, int>>>`

  * **特点分析**
    * 空间复杂度：O(n + m)
    * 适用稀疏图，需要遍历邻接点
    * 优势：空间效率高，适合度数不均的图
    * 劣势：判断边存在性需要遍历链表

  ### 十字链表 (Orthogonal List) - 有向图专用

  * **结构原理**
    * 同时存储顶点出边和入边信息
    * 顶点节点包含顶点数据、出边指针、入边指针
    * 边节点包含弧尾、弧头、权重、同弧尾指针、同弧头指针

  * **链表组织**
    * 出边链表：以顶点为弧尾的所有边
    * 入边链表：以顶点为弧头的所有边

  * **特点分析**
    * 空间复杂度：O(n + m)
    * 需要频繁查询顶点入度和出度
    * 优势：同时高效支持入边和出边遍历
    * 劣势：结构复杂，实现难度大

  ### 邻接多重表 (Adjacency Multilist) - 无向图专用

  * **结构原理**
    * 每条边只存储一次，被两个顶点共享
    * 顶点节点包含顶点数据、关联边指针
    * 边节点包含顶点i、顶点j、权重、顶点i指针、顶点j指针

  * **链表组织**
    * 顶点i边链表：所有与顶点i关联的边
    * 顶点j边链表：所有与顶点j关联的边
    * 同一条边同时出现在两个顶点链表中

  * **特点分析**
    * 空间复杂度：O(n + m)
    * 适用无向图，需要频繁删除边操作
    * 优势：边只存储一次，删除操作方便
    * 劣势：结构复杂，查询特定边效率低

  **存储结构对比总结**

  | 存储结构       | 适用图类型 | 空间复杂度 | 边查询 | 邻接点遍历 | 适用场景         |
  | -------------- | ---------- | ---------- | ------ | ---------- | ---------------- |
  | **邻接矩阵**   | 有向/无向  | O(n²)      | O(1)   | O(n)       | 稠密图，快速判边 |
  | **邻接表**     | 有向/无向  | O(n+m)     | O(d)   | O(d)       | 稀疏图，通用场景 |
  | **十字链表**   | 有向图     | O(n+m)     | O(d)   | O(d)       | 需要入度出度信息 |
  | **邻接多重表** | 无向图     | O(n+m)     | O(d)   | O(d)       | 无向图，频繁删边 |

  * d表示顶点度数，n表示顶点数，m表示边数

  ## Dijkstra算法

  **基本概念**

  单源最短路径算法，解决非负权图中从单个源点到其他所有顶点的最短路径问题。

  **核心思想**

  贪心策略，每次选择当前距离源点最近的未访问顶点，通过该顶点更新其邻接顶点的距离。

  **算法步骤**

  * 初始化距离数组，源点距离为0，其他为∞
  * 创建最小堆优先队列，放入源点
  * 循环直到队列为空：
    * 取出当前距离最小的顶点u
    * 标记u为已访问
    * 遍历u的所有邻接顶点v：
      * 如果dist[u] + w(u,v) < dist[v]，更新dist[v]
      * 将v加入优先队列

  **时间复杂度**

  * 普通数组实现：O(V²)
  * 二叉堆实现：O((V+E)logV)
  * 斐波那契堆实现：O(E + VlogV)

  **适用场景**

  * 非负权图的最短路径计算
  * 路由算法和网络优化
  * 需要单源最短路径的场景

---

  ## Floyd-Warshall算法

  **基本概念**

  多源最短路径算法，解决任意两点间的最短路径问题。

  **核心思想**

  动态规划，通过中间顶点k逐步优化所有顶点对(i,j)之间的距离。

  **算法步骤**

  * 初始化距离矩阵dist[][]
  * 三重循环遍历所有顶点：
    * 外层循环选择中间顶点k
    * 内层双重循环遍历所有顶点对(i,j)
    * 如果dist[i][k] + dist[k][j] < dist[i][j]，则更新

  **时间复杂度**

  * 时间复杂度：O(V³)
  * 空间复杂度：O(V²)

  **适用场景**

  * 稠密图的多源最短路径
  * 需要所有顶点对距离信息
  * 小规模图的全局路径规划

---

  ## Prim算法

  **基本概念**

  最小生成树算法，在加权无向图中找到连接所有顶点的最小权重边集合。

  **核心思想**

  贪心策略，从任意顶点开始，逐步扩展生成树，每次选择连接已选集和未选集的最小权重边。

  **算法步骤**

  * 初始化：选择任意顶点加入MST，标记为已访问
  * 创建优先队列存储连接边
  * 循环直到所有顶点被访问：
    * 取出权重最小的边(u, v, w)
    * 如果v未被访问：
      * 将v加入MST
      * 标记v为已访问
      * 将v的所有邻接边加入队列

  **时间复杂度**

  * 邻接矩阵实现：O(V²)
  * 二叉堆+邻接表实现：O(ElogV)

  **适用场景**

  * 无向连通图的最小生成树构建
  * 网络设计和电路布线
  * 聚类分析和图分割

---

  ## 图算法总结对比

  | 算法               | 类型         | 时间复杂度   | 空间复杂度 | 适用场景             |
  | ------------------ | ------------ | ------------ | ---------- | -------------------- |
  | **Dijkstra**       | 单源最短路径 | O((V+E)logV) | O(V)       | 非负权图，路由算法   |
  | **Floyd-Warshall** | 多源最短路径 | O(V³)        | O(V²)      | 稠密图，全局路径     |
  | **Prim**           | 最小生成树   | O(ElogV)     | O(V)       | 无向连通图，网络设计 |

  **选择指南**

  * **单源最短路径**：Dijkstra（适用于非负权图）
  * **所有顶点对最短路径**：Floyd-Warshall（适用于小规模稠密图）
  * **最小生成树**：Prim（稠密图）、Kruskal（稀疏图）
  * **负权边处理**：Bellman-Ford算法