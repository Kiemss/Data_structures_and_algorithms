# 笔记

## 容器函数命名规范

* 头插	push_front
  尾插	push_back
  头删	pop_front
  尾删	pop_back
* 检查是否存在  contain
  查找并返回迭代器  find
* 删除第一个指定元素  erase
  删除所有指定元素  remove
* 遍历  display



## 各种命名规范

* 蛇形命名法：函数名、文件名、变量名、命名空间名
* 大驼峰命名法：类名、枚举名



## 易错点

1. 成员函数在类内声明时若已经给出默认参数，则类外定义时无需给出默认参数

2. 默认参数中不能使用类的非静态成员变量，即使不使用 this 指针也不行。这是因为：

   * 默认参数在编译时确定

   * 非静态成员变量在运行时才存在

3. 设计类模板容器类时，对于返回容器内元素的函数的返回值：
   * 需要考虑存储的元素为类，那么此时返回拷贝就会调用拷贝构造函数，析构函数等，因此应该使用返回引用、const引用或者指针（还能使用std::optional或者span）。同时也要注意对于函数体内创建的临时类只能返回拷贝。

4. 关于类别名：

   1. 类别名需要在类定义后使用，如果将类别名放在完整类定义后，则类内定义的成员函数无法使用类别名
   1. 前置声明类，再使用类别名，就可以让成员函数使用类别名
   1. 遍历：到末尾了就从头循环可以使用模运算解决，index = (index + 1) % size
   1. 构造函数和析构函数**不允许**使用类别名

5. 对于编译期确定的常量，应该使用`constexpr`,相比于`const`的只允许整形常量类内初始化，`constexpr`允许所有字面量常量类内初始化
   对于函数：`constexpr`则是说明该函数的返回值应该在编译期能被确定，而`const`则是保证该函数不能修改类的成员变量（除非该变量被`mutable`修饰）

6. 关于**随机数**:

   ```cpp
   srand(time(NULL));
   int random_num = rand() % 10;
   ```

   * time()函数会将当前时间存储进参数（指针）中，同时当前时间也是返回值，传空指针作为参数即可
   * srand()函数会将time()返回的时间戳用于生成随机数种子
   * rand()函数会根据随机数种子生成随机数，每次调用都生成不同的随机数

7. `const`成员函数内不能调用非`const`成员函数！

8. ```c++
   template<typename Compare = std::less<int>>
   //Compare是一个函数类型，默认用less初始化（也就是如果没有传入Compare类型对象默认是less类型）
   Class BST
   {
   private:
       Compare m_compare;//Compare类型的对象m_compare
   public:
      BST(const Compare& comp = Compare()) : m_compare(comp){} 
      //用Compare类型的默认参数less对comp进行默认构造
   };
   ```

9. 递归：理清代码执行顺序

   ```cpp
   void recursive_func(){	
       //“递”时会执行的代码
   	recursive_func();//递归调用
       //“归”时会执行的代码
   }	
   ```

10. 递归：代码要连续（尤其指树中的递归），跳跃很容易导致逻辑混乱（比如node突然跳到其前驱上进行递归会导致前驱的父节点仍然指向原来的前驱节点而实际上应该指向node）

11. 关于`const`的修饰原则：先与左边结合，否则与右边结合。不会一次性结合多个（比如不会同时修饰Node*）

    * 实际上，解析时应该从变量开始向外解析

    ```cpp
    const int* ptr;//*->ptr是指针; int->ptr是int类型的指针;const我们提前修饰好int，说明指针ptr可以被修改，但是其指向的int不能被修改
    int* const ptr;//const->ptr不能被修改; *->ptr是指针; int->ptr是int类型的指针
    const Node* &ptr;//这是一个对Node*的引用；const只修改Node而不是Node*，也就是不能修改指针指向的对象
    ```

12. ```c++
    get_parent(child) = get_parent(node); //lvalue requied as left operand of assignment
    ```
	* 函数的返回值是一个右值，你不能将右值赋值给右值，除非你返回的是一个引用`&`
	* 可以如果返回值是一个指针左值，可以通过解引用`*`将其变成对象（是一个左值）
	* 如果一定要通过函数返回值的方式将指针赋值给指针，那就得返回指针引用`*&`
	
13. 当有符号数和无符号数进行比较时，有符号数会被**隐式转换为无符号数**，而不是取绝对值！
     `str.size() < -1 //size()函数返回的就是一个size_t类型数，-1会被转化为无符号数的最大值`

## 代码规范

1. 现代cpp中，关于`private`、`public`、`protected`的缩进：应该与关键字`class`平齐。
2. 类内`public`、`protected`、`private`顺序为从左到右，方便用户查阅接口。
3. 代码优化：把精力放在优化算法上。对于选择是否使用显示转换、写不写大括号这些细枝末节，坚持**可读性 > "优雅"**
4. 对于成员变量，成对数据使用突出特点的`key`和`val`，单个数据使用中性的`data`
5. 类内实现同一功能的函数，类内函数可以对比类外接口函数加上`impl`后缀或者前缀
6. 函数参数注意是否要使用`const`、`&`修饰。`const`修饰能保证不修改该变量，常用于插入、判断等操作，`&`修饰能保证操作能影响外部变量或调用时不是拷贝产生冗余的拷贝构造函数、析构函数（起到优化作用）
