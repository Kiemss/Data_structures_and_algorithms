# 笔记

## 容器函数命名规范

* 头插	push_front
  尾插	push_back
  头删	pop_front
  尾删	pop_back
* 检查是否存在  contain
  查找并返回迭代器  find
* 删除第一个指定元素  erase
  删除所有指定元素  remove
* 遍历  display



## 各种命名规范

* 蛇形命名法：函数名、文件名、变量名、命名空间名
* 大驼峰命名法：类名、枚举名



## 易错点

1. 成员函数在类内声明时若已经给出默认参数，则类外定义时无需给出默认参数

2. 默认参数中不能使用类的非静态成员变量，即使不使用 this 指针也不行。这是因为：

   * 默认参数在编译时确定

   * 非静态成员变量在运行时才存在

3. 设计类模板容器类时，对于返回容器内元素的函数的返回值：
   * 需要考虑存储的元素为类，那么此时返回拷贝就会调用拷贝构造函数，析构函数等，因此应该使用返回引用、const引用或者指针（还能使用std::optional或者span）。同时也要注意对于函数体内创建的临时类只能返回拷贝。

4. 关于类别名：

   1. 类别名需要在类定义后使用，如果将类别名放在完整类定义后，则类内定义的成员函数无法使用类别名
   1. 前置声明类，再使用类别名，就可以让成员函数使用类别名
   1. 遍历：到末尾了就从头循环可以使用模运算解决，index = (index + 1) % size
   1. 构造函数和析构函数**不允许**使用类别名

5. 对于编译期确定的常量，应该使用`constexpr`,相比于`const`的只允许整形常量类内初始化，`constexpr`允许所有字面量常量类内初始化
   对于函数：`constexpr`则是说明该函数的返回值应该在编译期能被确定，而`const`则是保证该函数不能修改类的成员变量（除非该变量被`mutable`修饰）

6. 关于**随机数**:

   ```cpp
   srand(time(NULL));
   int random_num = rand() % 10;
   ```

   * time()函数会将当前时间存储进参数（指针）中，同时当前时间也是返回值，传空指针作为参数即可
   * srand()函数会将time()返回的时间戳用于生成随机数种子
   * rand()函数会根据随机数种子生成随机数，每次调用都生成不同的随机数

7. `const`成员函数内不能调用非`const`成员函数！

8. ```c++
   template<typename Compare = std::less<int>>
   //Compare是一个函数类型，默认用less初始化（也就是如果没有传入Compare类型对象默认是less类型）
   Class BST
   {
   private:
       Compare m_compare;//Compare类型的对象m_compare
   public:
      BST(const Compare& comp = Compare()) : m_compare(comp){} 
      //用Compare类型的默认参数less对comp进行默认构造
   };
   ```
9. 
## 代码规范

1. 现代cpp中，关于`private`、`public`、`protected`的缩进：应该与关键字`class`平齐。
2. 类内`public`、`protected`、`private`顺序为从左到右，方便用户查阅接口。
3. 代码优化：把精力放在优化算法上。对于选择是否使用显示转换、写不写大括号这些细枝末节，坚持**可读性 > "优雅"**
4. 对于成员变量，成对数据使用突出特点的`key`和`val`，单个数据使用中性的`data`
5. 类内实现同一功能的函数，类内函数可以对比类外接口函数加上`impl`后缀或者前缀
6. 函数参数注意是否要使用`const`、`&`修饰。`const`修饰能保证不修改该变量，常用于插入、判断等操作，`&`修饰能保证操作能影响外部变量或调用时不是拷贝产生冗余的拷贝构造函数、析构函数（起到优化作用）
