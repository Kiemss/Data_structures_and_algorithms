# 专业数据结构

## 1. 跳表 (Skip List)

### 基本概念
跳表是一种概率性的数据结构，通过对有序链表添加多级索引来实现快速搜索。它是对有序链表的扩展，允许快速的查询、插入和删除操作。

### 核心特性
- **多层结构**：包含多个层级，底层包含所有元素，上层作为索引层
- **概率平衡**：通过随机算法决定节点层级，避免手动平衡
- **有序性**：所有元素在每层都保持有序
- **空间换时间**：通过额外空间换取搜索效率

### 时间复杂度
| 操作 | 平均复杂度 | 最坏复杂度 |
|------|------------|------------|
| 搜索 | O(log n) | O(n) |
| 插入 | O(log n) | O(n) |
| 删除 | O(log n) | O(n) |

### 关键指针：pre 和 cur
**pre（前驱指针）**
- 指向当前层的前一个节点
- 用于记录插入、删除操作时的位置
- 通常从高层向底层逐层记录

**cur（当前指针）**
- 指向当前正在检查的节点
- 用于遍历跳表的每一层
- 从高层开始，向右移动直到找到合适位置

### 核心操作
**插入操作流程**
1. 查找插入位置：从最高层开始，找到每层的前驱节点
2. 随机确定层级：通过抛硬币算法决定新节点层级
3. 调整头节点：如果新节点层级超过当前最大层级，增加头节点
4. 逐层插入：从高层到底层依次插入新节点

**删除操作流程**
1. 查找目标节点：记录每层的前驱节点
2. 逐层删除：从高层到底层删除目标节点
3. 清理空层：删除没有数据节点的空链表层

### 应用场景
- **Redis有序集合**：Redis使用跳表实现有序集合
- **内存数据库**：需要快速搜索和范围查询的场景
- **替代平衡树**：相比红黑树实现更简单，性能相当

### 优缺点
**优点**
- 实现相对简单
- 支持范围查询
- 插入删除不需要重新平衡
- 并行操作友好

**缺点**
- 空间复杂度较高
- 最坏情况下性能较差
- 依赖随机数生成质量

---

## 2. 字典树 (Trie)

### 基本概念
字典树，又称前缀树或单词查找树，是一种专门用于处理字符串的树形数据结构。它通过字符串的公共前缀来减少查询时间，用空间换时间。

### 核心特性
- **前缀共享**：具有相同前缀的字符串共享路径
- **快速检索**：搜索时间复杂度与字符串长度相关，与数据规模无关
- **自动排序**：遍历时自然按字典序输出
- **多模式匹配**：适合前缀匹配、模糊搜索等场景

### 时间复杂度
| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| 插入 | O(m) | m为字符串长度 |
| 搜索 | O(m) | m为字符串长度 |
| 前缀搜索 | O(m + k) | m为前缀长度，k为结果数量 |

### 节点结构
```cpp
struct TrieNode {
    char ch_;           // 节点存储的字符
    int freqs_;         // 以该节点结尾的单词频率
    map<char, TrieNode*> node_map_;  // 子节点映射
};
```

### 核心操作
**插入操作**
1. 从根节点开始遍历
2. 对于每个字符，如果对应子节点不存在则创建
3. 到达字符串末尾时增加词频

**查询操作**
1. 从根节点开始遍历
2. 如果路径中断返回0（未找到）
3. 到达末尾返回词频

**前缀查询**
1. 定位到前缀最后一个节点
2. 从前缀节点开始前序遍历，收集所有单词

**删除操作**
删除是Trie中最复杂的操作，需要考虑：
- **独立分支**：如果单词是独立分支，直接删除整条路径
- **共享前缀**：如果单词与其他单词共享前缀，只清除词频
- **中间节点**：如果删除的节点是其他单词的前缀，不能删除该节点

### 应用场景
- **搜索引擎**：搜索建议、自动补全
- **拼写检查**：单词存在性验证
- **IP路由**：最长前缀匹配
- **输入法**：词库管理和联想输入

### 变种优化
**压缩Trie**
- 合并只有一个子节点的路径
- 减少节点数量，节省空间

**双数组Trie**
- 使用两个数组表示Trie结构
- 空间效率更高，搜索更快

**三叉搜索Trie**
- 每个节点包含三个指针：小于、等于、大于
- 结合了二叉搜索树和Trie的优点

### 优缺点
**优点**
- 前缀搜索效率极高
- 支持模糊搜索和模式匹配
- 内存中操作快速

**缺点**
- 空间消耗较大
- 对于长字符串效率降低
- 实现相对复杂

---

## 3. 倒排索引 (Inverted Index)

### 基本概念
倒排索引是搜索引擎的核心技术，也称为反向索引。它通过词项到文档的映射，实现快速的全文搜索。

### 核心组件
**词典 (Lexicon)**
- 存储所有唯一的词项
- 包含词项的元数据（文档频率等）
- 提供快速词项查找

**倒排项 (Posting)**
```cpp
struct InvertTerm {
    string docid_;       // 文档ID
    int freqs_;          // 词频
    list<int> locations_; // 位置信息
};
```

**倒排列表 (Posting List)**
- 包含某个词项的所有倒排项
- 按文档ID排序，便于合并操作

### 构建流程
1. **文档收集**：递归收集目标文件
2. **文本处理**：读取文件，逐行处理
3. **词项提取**：分词、清理和标准化
4. **索引构建**：将词项映射到文档和位置信息

### 查询操作
**简单查询**
- 返回包含查询词的所有文档列表
- 时间复杂度：O(1) 词典查找 + O(k) 结果收集

**详细查询**
- 显示词项的完整信息：文档频率、词频、位置等
- 用于调试和分析索引质量

**布尔查询处理**
- **AND操作**：求倒排列表的交集
- **OR操作**：求倒排列表的并集  
- **NOT操作**：求倒排列表的差集

### 优化技术
**压缩技术**
- **词典压缩**：前缀编码、最小完美哈希
- **倒排列表压缩**：变长编码、差值编码

**排名算法**
- **TF-IDF**：词频-逆文档频率
- **BM25**：更先进的概率模型
- **PageRank**：网页重要性评分

### 应用场景
- **搜索引擎**：Google、Bing等搜索引擎核心
- **文档检索系统**：企业知识库、图书馆系统
- **代码搜索**：GitHub、SourceGraph等代码搜索工具
- **日志分析**：ELK Stack中的Elasticsearch

### 优缺点
**优点**
- 全文搜索效率极高
- 支持复杂的布尔查询
- 可扩展性强，支持分布式
- 成熟的生态系统和工具

**缺点**
- 构建和维护成本高
- 存储空间需求大
- 实时更新较复杂
- 需要专业的知识调优

---

## 总结对比

| 数据结构 | 主要特点 | 适用场景 | 时间复杂度 | 空间复杂度 |
|----------|----------|----------|------------|------------|
| **跳表** | 概率平衡、多层索引 | 有序数据快速搜索 | O(log n) | O(n log n) |
| **字典树** | 前缀共享、字符串专用 | 前缀匹配、自动补全 | O(m) | O(∑m) |
| **倒排索引** | 词项-文档映射 | 全文搜索、文档检索 | O(1)查询 | O(n + ∑t) |

**应用场景区分**

- **需要有序数据快速访问**：选择跳表

- **需要字符串前缀匹配**：选择字典树  

- **需要全文搜索功能**：选择倒排索引

  