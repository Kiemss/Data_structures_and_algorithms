# 哈希表(Hash Table)

## 一、定义

哈希表，又称散列表，是一种通过一个**散列函数 (Hash Function)** 将**键 (Key)** 映射到表中一个位置来访问记录的数据结构。这种映射过程称为**散列 (Hashing)**，映射到的位置称为**哈希地址**或**散列地址**。

**核心思想**：通过键值直接访问，使得在理想情况下，**查找**、插入和删除操作的时间复杂度都可以达到 **O(1)**。

1. **特点**：
   * **键值对存储**：存储的是键 (Key) 和值 (Value) 的配对。
   * **快速访问**：基于键的散列值进行快速查找。
   * **无序性**：元素在表中的存储位置由散列函数决定，与键的原始顺序无关（某些语言的实现，如 `Python 3.7+` 的 `dict`，保持了插入顺序，但这并非哈希表的核心定义特性）。
   * **键唯一性**：通常要求键是唯一的，相同的键经过散列后会指向同一个位置。

2. **优点**：

   - **访问速度快**：在无冲突或冲突较少时，查找、插入、删除的平均时间复杂度为 O(1)。（**应用于查找多的场景**）

   - **实现简单**：核心逻辑清晰，易于编码实现。

   - **灵活性高**：键的类型可以多样（整数、字符串、对象等），只要其可被散列。


3. **缺点**：

   - **空间效率可能低**：为减少冲突，哈希表通常需要预留较大的空闲空间（负载因子控制）。

   - **无序存储**：无法像数组或链表那样保持元素的自然顺序（除非使用额外数据结构）。

   - **哈希冲突不可避免**：只要数据量大于地址空间，根据鸽巢原理，冲突必然发生。

   - **性能不稳定**：最坏情况下，所有键都冲突，导致性能退化为 O(n)。

   - **依赖好的散列函数**：散列函数的质量直接决定了哈希表的性能。


## **二、核心组成部分**

### **1. 常用散列函数 (Hash Function)**

目标：将任意长度的输入（键）映射为固定长度的散列值，并尽可能均匀地分布在地址空间中。

| 方法名                  | 描述                                                         | 公式/示例                                   | 优点                                       | 缺点                                            |
| :---------------------- | :----------------------------------------------------------- | :------------------------------------------ | :----------------------------------------- | :---------------------------------------------- |
| **直接定址法**          | 直接取键的某个线性函数值为散列地址。                         | `hash(key) = a * key + b`                   | 简单，**无冲突**                           | 要求键的分布连续，否则会造成大量空间浪费。      |
| **除留余数法 (最常用)** | 用键除以表长 m 取余数作为散列地址。                          | `hash(key) = key % m`                       | 简单，计算快                               | 表长 m 的选择很关键，通常选**质数**以减少冲突。 |
| **数字分析法**          | 分析键的构成，抽取分布均匀的几位作为散列地址。               | 手机号后四位作为散列值。                    | 适合已知键的分布情况                       | 需要预先知道所有键的分布，通用性差。            |
| **平方取中法**          | 将键平方后，取中间几位作为散列地址。                         | `key=123`，`123^2=15129`，取中间 `512`      | 分布较均匀，隐藏了键的分布                 | 计算成本稍高。                                  |
| **折叠法**              | 将键分割成位数相同的几部分，然后相加作为散列地址。           | `key=123456`，分成 `12|34|56`，相加得 `102` | 适合键位数很多的情况                       | 不一定能保证均匀分布。                          |
| **乘法散列法**          | 1. 用键 k 乘一个常数 A (0<A<1)，取小数部分。<br>2. 再乘以 m 并取整。 | `hash(k) = floor(m * (k * A mod 1))`        | 对 m 的选择不敏感，通常选 2 的幂次         | 计算比除留余数法慢。                            |
| **全域散列法**          | 从一组精心设计的散列函数中随机选择一个来使用。               |                                             | **理论上**可以避免最坏情况，适用于任何键集 | 实现复杂，计算成本高。                          |

### **2. 冲突解决 (Collision Resolution)**

当两个不同的键被映射到同一个哈希地址时，称为**哈希冲突**。解决方法主要分为两类：

#### **A. 开放定址法 (Open Addressing)**

核心思想：当发生冲突时，通过某种**探测序列**在哈希表中寻找下一个空闲位置。

| 方法名                           | 探测序列                                  | 描述                               | 优点                               | 缺点                                                       |
| :------------------------------- | :---------------------------------------- | :--------------------------------- | :--------------------------------- | :--------------------------------------------------------- |
| **线性探测 (Linear Probing)**    | `h(k, i) = (hash(k) + i) % m`             | 顺序检查下一个位置，直到找到空位。 | 实现简单，缓存友好（局部性好）     | **一次聚集**：容易形成连续的被占用块，导致性能下降。       |
| **平方探测 (Quadratic Probing)** | `h(k, i) = (hash(k) + c₁*i + c₂*i²) % m`  | 以平方的步长进行探测。             | 缓解了一次聚集                     | **二次聚集**：可能发生，且不一定能找到空位（即使表未满）。 |
| **双重散列 (Double Hashing)**    | `h(k, i) = (hash₁(k) + i * hash₂(k)) % m` | 使用第二个散列函数来计算探测步长。 | 最好的开放定址方法，消除了聚集现象 | 计算两次散列，成本稍高。                                   |

#### **B. 链地址法 (Separate Chaining)**

核心思想：将映射到同一地址的所有元素存储在一个**链表**中。哈希表的每个位置是一个链表头。

- **操作**：
  - **插入**：计算 `hash(key)`，将键值对插入到对应链表中（头插或尾插）。
  - **查找**：计算 `hash(key)`，在对应链表中顺序查找。
  - **删除**：计算 `hash(key)`，在对应链表中找到并删除节点。
- **优点**：
  - 实现简单。
  - 无聚集现象。
  - 负载因子可以大于 1（链表可以无限延长）。
- **缺点**：
  - 需要额外的指针存储空间。
  - 缓存不友好（节点在内存中不连续）。
  - 小链表情况下性能优异，但链表过长时性能会退化为 O(n)。（在 Java 8 的 `HashMap` 中，当链表长度超过阈值时会转换为红黑树以优化性能）。

## **三、重要概念：负载因子 (Load Factor)**

- **定义**：`α = (表中已存元素个数 n) / (哈希表总大小 m)`。
- **意义**：衡量哈希表的装满程度。
- **作用**：
  - **性能指示器**：负载因子越高，发生冲突的概率越大，哈希表的性能越低。
  - **扩容触发器**：当负载因子超过某个阈值（如 0.75）时，通常需要执行 **Rehash** 操作：创建一个更大的新表，重新计算所有键的哈希值并插入到新表中，以维持 O(1) 的时间复杂度。

# 大数据查重与topk问题

## 哈希表

**原理**

* 基于哈希函数将键(key)映射到数组的特定位置
* 通过解决哈希冲突（开放地址法、链地址法等）来存储多个元素

**优点**

* 查询、插入、删除操作的时间复杂度接近O(1)
* 操作速度快，实现相对简单
* 各种编程语言都有内置实现

**缺点**

* 需要占用较多内存空间，存储效率不高
* 哈希冲突会影响性能
* 无法支持范围查询，只能精确查找

**适用场景**

* 数据量不是特别巨大，需要快速精确查找、去重的场景
* 内存充足时的数据索引和字典类应用

## 位图 (Bit map)

**原理**

* 使用比特位来标记元素是否存在
* 每个元素用一个或多个比特位表示
* 通过位运算实现快速的查询和设置

**优点**

* 空间效率极高，特别适合整数型数据
* 查询和设置操作都是O(1)时间复杂度
* 支持快速的位运算操作（与、或、非）

**缺点**

* 只能处理整数类型数据
* 数据范围较大时仍会占用较多内存
* 无法存储额外信息，只能记录存在性

**适用场景**

* 整数数据的大规模存在性判断
* 数据范围相对集中的去重场景
* 需要高性能位运算的应用

## 布隆过滤器 (Bloom Filter)

**原理**

* 使用一个大型位数组和多个哈希函数
* 添加元素时，通过多个哈希函数计算多个位置并置为1
* 查询元素时，检查所有哈希位置是否都为1

**优点**

* 空间效率极高，远超过其他数据结构
* 查询时间与数据量大小无关
* 添加和查询操作都是常数时间复杂度

**缺点**

* 存在误判率（可能将不存在的元素判为存在）
* 不能删除已添加的元素（计数布隆过滤器除外）
* 无法实际存储数据本身

**适用场景**

* 大数据量下的快速存在性判断
* 能够接受一定误判率的去重场景
* 缓存穿透防护、爬虫URL去重等

## topK 问题解法

  1. **堆解法**

     - **求最大K个**：小根堆，比堆顶大就替换

     - **求最小K个**：大根堆，比堆顶小就替换

     - 时间复杂度：O(nlogk)
     - 适用场景：数据流场景，内存有限

  2. **快排分割法**  

     - 每次分割后判断基准位置

     - 基准在K右边 → 继续分割左区间

     - 基准在K左边 → 继续分割右区间（调整K值）

     - 基准等于K → 前K个已就位

     - 时间复杂度：平均O(n)，最坏O(n²)
     - 适用场景：数据可全部加载，追求平均性能