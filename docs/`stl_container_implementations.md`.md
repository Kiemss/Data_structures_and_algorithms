# STL容器底层实现总结

## 线性结构

### `std::vector`
*   **底层数据结构**：动态分配的连续数组
*   **核心机制**：
    *   维护三个指针：`start`、`finish`、`end_of_storage`
    *   扩容时通常按原有容量的一定比例（如1.5或2倍）重新分配内存，并将原有元素移动或拷贝到新空间
*   **关键特性**：
    *   随机访问时间复杂度 O(1)
    *   尾部插入/删除平均时间复杂度 O(1)
    *   在尾部以外的位置插入/删除时间复杂度 O(n)

### `std::deque` (双端队列)
*   **底层数据结构**：分段连续的多段数组（指针数组 + 数据块）
*   **核心机制**：
    *   由一个中控器（数组）管理多个固定大小的数据块
    *   中控器数组存储指向各数据块的指针
*   **关键特性**：
    *   在头尾进行插入/删除操作的时间复杂度为 O(1)
    *   随机访问时间复杂度 O(1)，但常数项比`vector`大

### `std::list`
*   **底层数据结构**：双向链表
*   **核心机制**：
    *   每个节点包含数据域、指向前驱节点的指针、指向后继节点的指针
    *   通常实现为环形链表，包含一个哨兵节点
*   **关键特性**：
    *   在任意位置插入/删除时间复杂度 O(1)（已知迭代器位置）
    *   不支持随机访问

### `std::forward_list` (C++11)
*   **底层数据结构**：单向链表
*   **核心机制**：
    *   每个节点包含数据域和指向下一个节点的指针
*   **关键特性**：
    *   内存开销小于`std::list`
    *   仅支持单向遍历

## 关联式容器

### `std::set` / `std::multiset`
*   **底层数据结构**：红黑树（平衡二叉搜索树）
*   **核心机制**：
    *   红黑树通过颜色标记和旋转操作维持平衡
    *   保证树的高度始终为 O(log n)
*   **关键特性**：
    *   元素自动排序
    *   查找、插入、删除操作的时间复杂度 O(log n)

### `std::map` / `std::multimap`
*   **底层数据结构**：红黑树
*   **核心机制**：
    *   每个节点存储`std::pair<const Key, Value>`键值对
    *   按Key进行排序和平衡
*   **关键特性**：
    *   按键自动排序
    *   查找、插入、删除操作的时间复杂度 O(log n)

## 无序关联式容器 (C++11)

### `std::unordered_set` / `std::unordered_multiset`
*   **底层数据结构**：哈希表（数组 + 链表/红黑树）
*   **核心机制**：
    *   通过哈希函数将元素映射到数组的特定位置（桶）
    *   使用链表法解决哈希冲突
    *   当负载因子超过阈值时进行重新哈希
*   **关键特性**：
    *   元素无序存储
    *   平均情况下查找、插入、删除操作的时间复杂度 O(1)

### `std::unordered_map` / `std::unordered_multimap`
*   **底层数据结构**：哈希表
*   **核心机制**：
    *   每个桶中存储`std::pair<const Key, Value>`键值对
    *   通过Key的哈希值确定存储位置
*   **关键特性**：
    *   按键的哈希值无序存储
    *   平均情况下查找、插入、删除操作的时间复杂度 O(1)

## 容器适配器

### `std::stack`
*   **底层容器**：默认使用`std::deque`，也可指定为`std::vector`或`std::list`
*   **接口限制**：仅提供LIFO（后进先出）操作接口

### `std::queue`
*   **底层容器**：默认使用`std::deque`，也可指定为`std::list`
*   **接口限制**：仅提供FIFO（先进先出）操作接口

### `std::priority_queue`
*   **底层容器**：默认使用`std::vector`
*   **底层数据结构**：二叉堆（通常是大顶堆）
*   **核心机制**：
    *   通过堆算法维护元素的部分有序性
    *   使用`std::make_heap`、`std::push_heap`、`std::pop_heap`等算法操作
*   **关键特性**：
    *   获取最大/最小元素的时间复杂度 O(1)
    *   插入/删除操作的时间复杂度 O(log n)

## 总结表格

| 容器 | 底层数据结构 | 排序 | 查找复杂度 | 插入复杂度 | 关键特性 |
|------|-------------|------|------------|------------|----------|
| `vector` | 动态数组 | 无 | O(1) | 尾部O(1) | 随机访问高效 |
| `deque` | 分段数组 | 无 | O(1) | 头尾O(1) | 双端操作高效 |
| `list` | 双向链表 | 无 | O(n) | O(1) | 任意位置插入删除 |
| `set/map` | 红黑树 | 是 | O(log n) | O(log n) | 自动排序 |
| `unordered_set/map` | 哈希表 | 无 | 平均O(1) | 平均O(1) | 哈希查找高效 |