* # 回溯算法

  * 穷举法，效率和空间复杂度低，但是是通法，容易使用
  * 可以在递归过程中进行计算
  * 分为子集树和排列树

  ## 子集树

  * 数组一开始是空的，每次循环：
    1. 穷举：选择是否填入给定数组中第i个数字，然后i++
    2. 全排列：填入之前未选过的数字

  **图示：**
  ```
  初始状态: []
         /          \
  包含元素1       不包含元素1
      /    \         /    \
  包含2  不包含2  包含2  不包含2
   / \     / \     / \     / \
  ... ... ... ... ... ... ... ...
  叶子节点: [1,2] [1] [2] []
  ```

  ## 排列树

  * 每层将第n个数和后面的数依次交换，n++

  **图示：**
  ```
  初始: [1,2,3]
       /     |     \
  [1,2,3]  [2,1,3]  [3,2,1]  ← 第一层：固定第一位
    /  \    /  \    /  \
  ...  ... ...  ... ... ...   ← 第二层：固定第二位
  ```

  ## 剪枝操作

  * 如果选择后sum > target，剪枝
  * 如果sum + less < target (全选也没法打到target)，剪枝
  * 对于选择顺序不同但是结果一样（也就是形成的集合相同）的，要剪枝

  **剪枝图示：**
  ```
  目标sum=5, 数组[2,3,4]
  []
  ├─ [2] (sum=2)
  │  ├─ [2,3] (sum=5) ✓ 保留
  │  └─ [2,4] (sum=6) ✗ 剪枝
  └─ [3] (sum=3)
     └─ [3,4] (sum=7) ✗ 剪枝
  ```

  ## 优化

  要找最优，应该用一个变量存储最优，到达叶子节点时和最优比较，而不是用数组存储所有选项，在最后再比较所有情况

  # 分治算法

  * 规模太大，无法求解，但是可以被划分为规模更小的子问题
  * 子问题应该互不重复/互不影响
  * 原问题无法被直接求出，需要分解到子问题能被直接求解再回溯

  **分治过程图示：**
  ```
        问题P
       /  |  \
     P1   P2  P3     ← 分解
    /|\   ...  
  P11 P12 P13        ← 继续分解
   |   |   |  
  基情况 基情况 基情况 ← 解决
   \   \   /
    合并结果          ← 合并
  ```

  **典型应用：**
  - 归并排序：分解→排序子数组→合并
  - 快速排序：分区→递归排序→无需合并
  - 二叉树问题：左子树 + 右子树

  # 动态规划

  * 最优子结构性质
  * 需要状态转移方程  
  * 需要记忆已有最优解

  **核心思想图示：**
  ```
  问题: 求到第n步的最优解
  f(0) → f(1) → f(2) → ... → f(n)
    ↓      ↓      ↓           ↓
  已知  利用f(0) 利用f(1)   利用f(n-1)
  ```

  **实现方式：**
  1. **自底向上**：从基础情况开始逐步构建
  2. **自顶向下**：递归+记忆化，避免重复计算

  **关键步骤：**
  - 定义状态：dp[i] 表示什么
  - 状态转移：dp[i] = f(dp[i-1], ...)
  - 初始条件：dp[0], dp[1] 等基础情况
  - 确定计算顺序

  # 贪心算法

  * 局部最优解组成总体最优解（当然不一定能得到最优解）
  * 最优子结构性质（动态规划能做的用贪心说不定也能做）

  **决策过程图示：**
  ```
  每一步选择当前最优
  初始 → 选择1 → 选择2 → ... → 最终解
         ↓       ↓
       局部最优 局部最优
  ```

  **适用条件：**
  - 贪心选择性质：局部最优能导致全局最优
  - 最优子结构：问题的最优解包含子问题的最优解

  **与动态规划对比：**
  - 贪心：一旦选择永不回溯，效率高但不保证最优
  - 动态规划：考虑所有可能性，保证最优但复杂度高

  # 分支限界算法

  ## 基本概念
  * 广度优先或最佳优先的方式系统搜索解空间
  * 使用**界限函数**来剪去不可能产生最优解的分支
  * 通常用**优先队列**管理活节点

  ## 与回溯法的区别
  | 特征     | 回溯法   | 分支限界法        |
  | -------- | -------- | ----------------- |
  | 搜索方式 | 深度优先 | 广度优先/最佳优先 |
  | 存储结构 | 栈       | 队列/优先队列     |
  | 求解目标 | 所有解   | 一个最优解        |
  | 节点扩展 | 一次一个 | 一次一批          |

  ## 搜索过程图示
  ```
  初始节点(界限值=20)
       |
      扩展
     /  |  \
  子节点A(18) 子节点B(15) 子节点C(25)
    |     |     ✗ 剪枝(超过界限)
    |     |
   优先扩展 下次扩展
  (值更优)
  ```

  ## 两种实现策略

  ### 1. 队列式分支限界法
  ```
  队列: [根节点]
  while 队列非空:
      出队一个节点
      扩展该节点生成所有子节点
      计算每个子节点的界限值
      将满足界限的子节点入队
  ```

  ### 2. 优先队列式分支限界法
  ```
  优先队列: [根节点]
  while 队列非空:
      出队界限值最优的节点
      如果是叶子节点且优于当前最优 → 更新最优解
      否则扩展节点，计算界限，将有望的子节点入队
  ```

  ## 界限函数设计
  * **上界函数**：对于最大化问题，估计该分支可能达到的最大值
  * **下界函数**：对于最小化问题，估计该分支可能达到的最小值
  * 当界限不如当前最优解时，剪枝

  ## 典型应用
  - **0-1背包问题**：用价值密度计算上界
  - **旅行商问题**：用最小生成树计算下界
  - **作业调度问题**：用处理时间估算界限

  ## 算法选择策略

  | 情况                        | 推荐算法     |
  | --------------------------- | ------------ |
  | 需要遍历所有解              | 回溯         |
  | 问题可递归分解              | 分治         |
  | 有最优子结构+重叠子问题     | 动态规划     |
  | 局部最优导致全局最优        | 贪心         |
  | **找单一最优解+可估算界限** | **分支限界** |