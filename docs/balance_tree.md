## B树 (B-Tree)

* 由于每个节点能装大量的元素，因此B树可以非常“矮胖”，从而起到减少磁盘I/O的作用

---

### **特点 (对于 m 阶 B树)**

1.  ⭐根节点比较特殊：其**最小子节点数**为**2**，**最小元素数**为**1**
2.  ⭐每个节点的**最大子节点数**为 **m**,**最大元素数**为 **m-1**
3.  ⭐每个节点的**最小子节点数**为 $[\frac{m}{2}]$）,**最小元素数**为 **$$[\frac{m}{2}] - 1$$**
4.  每个节点中的元素按键值升序排列。
5.  一个节点中的 k 个元素，正好有 k+1 个子指针。
6.  **所有叶子节点都位于同一层**，这是树平衡的关键标志。
7.  节点中的数据元素充当分隔值，将其子树的范围划分开来。对于一个节点中的元素 `K₁, K₂, ..., Kₖ`，其子树 `P₀, P₁, ..., Pₖ` 满足：
    *   子树 `P₀` 中的所有元素 < `K₁`
    *   子树 `P₁` 中的所有元素介于 `K₁` 和 `K₂` 之间
    *   ...
    *   子树 `Pₖ` 中的所有元素 > `Kₖ`

---

### **适用范围 **

B树的核心优势在于**减少磁盘I/O**。

*   **数据库和文件系统索引**：这是B树最经典和广泛的应用。数据库的表索引（如MySQL的InnoDB引擎）和文件系统（如NTFS, ReiserFS）的目录结构大量使用B树或其变种（如B+树）。
*   **当数据量太大，无法全部装入内存时**：B树被设计用来处理这种情况。与二叉搜索树（BST）或AVL树相比，B树的节点可以存储大量键值，使得树的高度非常低。
    *   **举例**：一个深度为3的256阶B树，可以存储 `(256^3 - 1) ≈ 1600万` 个键。而一个包含1600万个节点的二叉搜索树，深度可能达到24层。每次访问节点都可能需要一次磁盘读取，因此将磁盘访问次数从24次减少到3次，性能提升是巨大的。
*   **需要高效的范围查询、顺序访问时**：B树的变种**B+树**在这方面表现更优，因为B+树的所有数据都存储在叶子节点，并形成链表，非常适合范围扫描。

---

### **插入操作**

插入操作总是在叶子节点进行。基本步骤如下：

1.  **搜索**：从根节点开始，找到应该插入的叶子节点。
2.  **插入**：将新键值插入到该叶子节点的正确位置（保持有序）。
3.  **检查节点溢出**：插入后，检查该叶子节点的键数量是否超过了最大值 `m-1`。
    *   **如果未溢出**：插入结束。
    *   **如果溢出**：需要进行**分裂**。
4.  **分裂节点**：
    a. 从该溢出节点中取出中间位置**i = $[\frac{m}{2}]$**的键（假设为 `mid`）。
    b. 以此键为界，将原节点分裂成两个新节点：左节点包含 `mid` 左边的键，右节点包含 `mid` 右边的键。
    c. 将 `mid` 键**提升**到父节点中，并为其左右两个新节点建立指针。
5.  **递归检查父节点**：将键提升到父节点后，可能导致父节点溢出。重复步骤3和4，继续向上分裂，直到不再溢出或到达根节点。
6.  **根节点分裂**：如果根节点发生溢出，则对其进行分裂。被提升的 `mid` 键将成为一个新的根节点，此时B树的高度会增加1。

---

### **删除操作**

删除操作比插入更复杂，因为可能从内部节点删除。基本思想是确保删除后节点不“下溢”（即键数不少于 `⌈m/2⌉ - 1`）。

1.  **定位**：找到要删除的键所在节点。
2.  **情况一：键在内部节点**（相当于删除二叉树中有两个子节点的节点）
    *   找到该键的**前驱**（左子树中最右边的键）或**后继**（右子树中最左边的键）。这两个键必然位于叶子节点。
    *   用这个前驱或后继键**替换**要删除的内部节点键。
    *   **问题转化为删除叶子节点中的那个前驱或后继键**，然后按照**情况二**来处理。
3.  **情况二：键在叶子节点**
    *   直接从中删除该键。
    *   **检查下溢**：如果删除后，该节点的键数 **不小于** `⌈m/2⌉ - 1`，则结束。
    *   **如果下溢**：
        a. **借兄弟**：检查其左或右兄弟节点是否有富余的键（键数 > `⌈m/2⌉ - 1`）。如果有，则从父节点借一个分隔键下来，同时将兄弟节点的一个键提升到父节点。
        b. **合并**：如果左右兄弟节点都没有富余键，则将该节点与一个兄弟节点以及父节点中它们之间的分隔键**合并**成一个新节点。
        c. **递归检查父节点**：合并操作会导致父节点减少一个键和一个指针，因此父节点可能发生下溢。重复此过程，直到不再下溢或到达根节点。

### **总结**

| 操作     | 核心思想         | 关键步骤                                                     |
| :------- | :--------------- | :----------------------------------------------------------- |
| **插入** | 防止节点**溢出** | 搜索 -> 叶子节点插入 -> 溢出则**分裂**                       |
| **删除** | 防止节点**下溢** | 搜索 -> 若为内部节点则找前驱/后继替换 -> 叶子节点删除 -> 下溢则**借兄弟**或**合并** |

---

## B+树 (B+ Tree)

* B+树是B树的一种变体，**所有数据记录都存储在叶子节点**，内部节点只起索引作用。

---

### **特点 (对于 m 阶 B+树)**

1.  ⭐根节点比较特殊：其**最小子节点数**为**2**
2.  ⭐每个节点的**最大子节点数**为 **m**，**最大元素数**为 **m-1**
3.  ⭐每个节点的**最小子节点数**为 **⌈m/2⌉**（根除外）
4.  **内部节点（非叶子节点）只包含键**，不包含实际的数据记录，仅用作索引。
5.  **所有叶子节点包含了全部的关键字信息**以及指向数据记录的指针。
6.  **所有叶子节点之间通过指针连接成一个有序链表**，支持高效的范围查询。
7.  内部节点中的每个键都是其子树中的**最大键**（或最小键）的副本。
8.  叶子节点中的 k 个元素，有 k 个子指针（指向数据）。
9.  相比于B树，能支持**随机访问**（B树的通过**中序遍历**支持的**伪**随机访问I/O次数多，效率低下）

---

### **适用范围**

⭐相比于B树，B+树的索引节点不用放val，因此**每个节点可以容纳更多的键**，**树高更低**，**索引速度更快**，**缓存效率也更高**

*   **数据库索引**：是现代关系型数据库（MySQL InnoDB, Oracle等）最主流的索引结构。
*   **文件系统**：如NTFS、ReiserFS等。
*   **需要频繁的范围查询和顺序访问的场景**：因为叶子节点的链表结构可以快速进行全表扫描和范围查找。

---

### **插入操作**

1.  **搜索**：找到应插入的叶子节点。
2.  **插入**：将新键插入叶子节点（保持有序），如果该键大于当前子树最大值，需要更新所有祖先节点中的对应索引键。
3.  **检查溢出**：如果叶子节点键数 > m-1，则分裂。
4.  **分裂叶子节点**：
    a. 取中间位置 **i = ⌈m/2⌉** 的键。
    b. 左叶子节点包含前 i 个键，右叶子节点包含剩余键。
    c. **将右节点的第一个键复制（不是移动）到父节点**中作为索引。
    d. 更新叶子节点的链表指针。
5.  **递归检查父节点**：父节点插入新键后可能溢出，继续分裂（分裂内部节点流程同B树）。

---

### **删除操作**

1.  **定位**：找到包含要删除键的叶子节点。
2.  **删除**：直接从叶子节点中删除该键。
3.  **检查下溢**：如果叶子节点键数 < ⌈m/2⌉ - 1：
    a. **借兄弟**：从兄弟节点借一个键，并更新父节点中的索引键。
    b. **合并**：若兄弟节点不够借，则与兄弟节点合并，并删除父节点中对应的索引键。
4.  **更新索引**：如果删除的是当前子树的最大键，需要更新祖先节点中的索引键。
5.  **递归检查**：父节点删除键后可能下溢，继续处理。

---

### **与B树对比**

| 特性             | B树                    | B+树                 |
| ---------------- | ---------------------- | -------------------- |
| **数据存储**     | 所有节点都可能存储数据 | 只有叶子节点存储数据 |
| **叶子节点链接** | 无                     | 有有序链表           |
| **查询性能**     | 随机查询快             | 随机和范围查询都很快 |
| **内部节点**     | 包含键和数据           | 只包含键（纯索引）   |
| **空间利用率**   | 相对较低               | 更高（内部节点更小） |

---

## B\*树 (B\* Tree)

* B*树是B树的另一种变体，核心目标是**提高节点的空间利用率**，通过**延迟分裂**和**节点重新分配**来实现。

---

### **特点 (对于 m 阶 B*树)**

1.  ⭐根节点比较特殊：其**最小子节点数**为**2**，**最小元素数**为**1**
2.  ⭐每个节点的**最大子节点数**为 **m**，**最大元素数**为 **m-1**
3.  ⭐每个**非根节点**的**最小子节点数**为 **⌈(2m-1)/3⌉**，**最小元素数**为 **⌈(2m-1)/3⌉ - 1**
4.  每个节点中的元素按键值升序排列。
5.  一个节点中的 k 个元素，正好有 k+1 个子指针。
6.  **所有叶子节点都位于同一层**。
7.  **兄弟节点之间通过指针连接**，方便键的重新分配。

---

### **适用范围**

*   **写入操作非常频繁**且对**查询性能要求极高**的系统。
*   需要**更高空间利用率**的存储系统。
*   在实际应用中不如B+树普及，但其设计思想很有影响力。

---

### **插入操作**

1.  **搜索**：找到应插入的叶子节点。
2.  **插入**：将新键插入到节点中（保持有序）。
3.  **检查溢出**：如果节点键数 > m-1：
    a. **优先重新分配**：检查兄弟节点是否有空闲。如果有，将当前节点、兄弟节点和父节点分隔键**重新排序平均分配**。
    b. **三次分裂**：如果两个兄弟节点都满了，将当前节点和两个兄弟节点**合并后重新分配成三个节点**（相当于把当前节点和兄弟节点以及被夹在中间的两个父节点中的元素排序后重新分配成三个节点），并向父节点插入两个新键。
4.  **递归检查**：父节点插入新键后可能溢出，继续处理。

---

### **删除操作**

1.  **定位**：找到要删除的键所在节点。
2.  **情况一：键在内部节点**：用前驱或后继替换，转为删除叶子节点中的键。
3.  **情况二：键在叶子节点**：直接删除。
4.  **检查下溢**：如果节点键数 < ⌈(2m-1)/3⌉ - 1：
    a. **借兄弟**：从兄弟节点转移键，更新父节点分隔键。
    b. **合并**：如果兄弟节点也不够，进行节点合并（兄弟节点、父节点和该节点合并成一个节点）。
5.  **递归检查**：处理可能下溢的父节点。

---

### **与B树对比**

| 特性           | B树            | B*树                       |
| -------------- | -------------- | -------------------------- |
| **最小填充度** | ≈50%           | ≈66.7%                     |
| **空间利用率** | 相对较低       | 更高                       |
| **分裂策略**   | 直接分裂成两个 | 先重新分配，失败则三路分裂 |
| **实现复杂度** | 相对简单       | 更复杂                     |
| **分裂频率**   | 较高           | 较低                       |

## **对比**

| 树类型   | 核心优势             | 主要应用             |
| -------- | -------------------- | -------------------- |
| **B树**  | 结构简单，随机查询快 | 文件系统，早期数据库 |
| **B+树** | 范围查询优，适合磁盘 | 现代数据库索引       |
| **B*树** | 空间利用率高，树更矮 | 特定高性能存储系统   |
